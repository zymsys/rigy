# Rigy — RigSpec YAML (v0.3-rc2)

**Pronunciation**
- **Rigy**: "RIG-ee"
- **Ricy** (RigSpec Contract YAML): "RYE-see"
- **Rigs** (RigSpec Scene / Layout): "RIGS"

Rigy is a **text-based specification language for rigged assemblies of geometric primitives**.
It enables deterministic, tool-friendly construction of reusable 3D assets that compile to
standard formats such as **glTF** and **FBX**.

Rigy v0.3 introduces **vertex-weighted skinning**: per-vertex joint influences that enable
smooth deformation across bone boundaries, replacing the rigid per-primitive model as the
primary skinning mechanism.

---

## Scope of v0.3

Rigy v0.3 adds:
- Per-vertex weight maps (inline YAML and external JSON)
- Parametric weight gradients for smooth joint transitions
- Raw vertex-index overrides as an escape hatch
- Formalized Linear Blend Skinning (LBS) equation

Rigy v0.3 retains from v0.2:
- Geometric primitives, armatures, per-primitive skinning
- Asset imports, anchors, `attach3`, contracts

Rigy v0.3 intentionally does **not** support:
- Dual quaternion skinning
- Corrective blendshapes or pose-space deformation
- Animation curves, constraints, or IK
- Muscle, soft tissue, cloth, or physics-based deformation
- Weight painting workflows or authoring tools

---

## Migration from v0.2

Per-primitive weights (`bindings[].weights[].bones`) remain valid in v0.3. They are
treated as syntactic sugar: all vertices generated by a primitive receive identical
joint influences, exactly as in v0.2.

When both per-primitive weights and per-vertex weight maps target the same primitive,
the per-vertex weight map takes precedence and the per-primitive entry is ignored for
that primitive.

Existing v0.2 assets are valid v0.3 assets with no changes required.

---

## Coordinate System & Units

Unchanged from v0.2. Rigy uses a canonical coordinate system aligned with **glTF 2.0**.

```yaml
units: meters
coordinate_system:
  up: Y
  forward: -Z
  handedness: right
```

---

## Skinning Model

### Per-Primitive Weights (v0.1 Compatible)

All vertices generated by a primitive receive identical weights. This remains the simplest
way to skin rigid or semi-rigid parts.

```yaml
bindings:
  - mesh_id: robot_arm
    armature_id: arm_skeleton
    weights:
      - primitive_id: upper_arm
        bones:
          - bone_id: upper_arm_bone
            weight: 1.0
      - primitive_id: forearm
        bones:
          - bone_id: forearm_bone
            weight: 1.0
```

### Per-Vertex Weight Maps (New in v0.3)

Weight maps define per-vertex joint influences on a binding. They are specified under a
new `weight_maps` key on the binding object.

### Vertex Addressing Model

Rigy primitives are tessellated by the compiler, so authors generally do not control
raw vertex indices. Therefore, v0.3 defines **parametric gradients** as the primary
authoring model for per-vertex weights.

Raw vertex-index overrides are supported only as an **escape hatch** for edge cases.
Because they are tied to a primitive’s tessellation output ordering, authors SHOULD
prefer gradients whenever possible.

A conforming implementation MUST:
- Define a canonical tessellation ordering per primitive type (so gradients and overrides
  remain meaningful and deterministic).
- Apply gradients first, then apply raw index overrides last (then renormalize + truncate).

A weight map targets a single primitive within the bound mesh and assigns vertex-level
joint influences using one or more strategies: **gradients**, **raw indices**, or both.

```yaml
bindings:
  - mesh_id: character_torso
    armature_id: skeleton
    weights:
      - primitive_id: torso
        bones:
          - bone_id: spine
            weight: 1.0
    weight_maps:
      - primitive_id: torso
        gradients:
          - axis: y
            range: [0.3, 0.7]
            from: { bone_id: spine, weight: 1.0 }
            to:   { bone_id: chest, weight: 1.0 }
        overrides:
          - vertices: [0, 1, 2]
            bones:
              - bone_id: spine
                weight: 0.8
              - bone_id: neck
                weight: 0.2
```

#### Schema: `weight_maps[]`

| Field          | Type                    | Required | Description |
|----------------|-------------------------|----------|-------------|
| `primitive_id` | `string`                | Yes      | Target primitive within the bound mesh |
| `gradients`    | `list[Gradient]`        | No       | Parametric weight transitions |
| `overrides`    | `list[VertexOverride]`  | No       | Raw vertex-index overrides (escape hatch; indices follow canonical tessellation order) |
| `source`       | `string`                | No       | Path to external JSON weight file |

At least one of `gradients`, `overrides`, or `source` MUST be present.

#### Schema: `Gradient`

| Field   | Type                          | Required | Description |
|---------|-------------------------------|----------|-------------|
| `axis`  | `"x"` \| `"y"` \| `"z"`     | Yes      | Axis along which the gradient varies |
| `range` | `[float, float]`             | Yes      | Start and end positions in mesh space |
| `from`  | `BoneWeight` or `list[BoneWeight]` | Yes | Joint influences at the start of the range |
| `to`    | `BoneWeight` or `list[BoneWeight]` | Yes | Joint influences at the end of the range |

The gradient defines a linear interpolation of joint influences along the specified axis.
For a vertex at position `p` on the given axis:

- If `p <= range[0]`: vertex receives `from` weights
- If `p >= range[1]`: vertex receives `to` weights
- Otherwise: weights are linearly interpolated by `t = (p - range[0]) / (range[1] - range[0])`

`range[0]` MUST be strictly less than `range[1]`.

When multiple gradients affect the same vertex, they are applied in declaration order.
Later gradients overwrite influences set by earlier ones.

#### Schema: `VertexOverride`

| Field      | Type               | Required | Description |
|------------|--------------------|----------|-------------|
| `vertices` | `list[int]`        | Yes      | Vertex indices (tessellation order) |
| `bones`    | `list[BoneWeight]` | Yes      | Joint influences for these vertices |

Vertex indices are zero-based and refer to the tessellation output order for the
target primitive. Indices MUST be within bounds for the primitive's vertex count.

Overrides are applied **after** gradients and per-primitive weights. They replace
(not blend with) any previously computed influences for the specified vertices.

#### External Weight Files

When `source` is specified, it points to a JSON file containing a complete vertex
weight map for the primitive.

```json
{
  "primitive_id": "torso",
  "vertex_count": 128,
  "influences": [
    { "vertex": 0, "bones": [{ "bone_id": "spine", "weight": 0.8 }, { "bone_id": "chest", "weight": 0.2 }] },
    { "vertex": 1, "bones": [{ "bone_id": "spine", "weight": 1.0 }] }
  ]
}
```

The file path is resolved relative to the `.rigy.yaml` file.

Vertices not listed in the `influences` array fall back to the per-primitive weights
if defined, or to the default binding behavior (see §Default Binding).

When `source` is present alongside `gradients` or `overrides`, the external file is
loaded first, then gradients and overrides are applied on top in that order.

---

## Influence Resolution Order

For a given vertex, influences are resolved in the following priority (last wins):

1. **Default binding** — rigidly bound to the armature root bone (weight 1.0)
2. **Per-primitive weights** — from `bindings[].weights[].bones`
3. **External weight file** — from `weight_maps[].source`
4. **Gradients** — from `weight_maps[].gradients`, in declaration order
5. **Overrides** — from `weight_maps[].overrides`, in declaration order

At each stage, the new influences fully replace the previous ones for the affected
vertices. There is no additive blending between stages.

---

## Joint Influence Limits (Normative)

Conforming implementations MUST support at least 4 joint influences per vertex,
matching the glTF `JOINTS_0` / `WEIGHTS_0` attribute set.

When a vertex has more than 4 joint influences after resolution:

1. Sort influences by weight, descending
2. Retain the top 4
3. Renormalize retained weights to sum to 1.0
4. Emit a **warning** identifying the affected vertex and dropped joints

Implementations MUST NOT silently discard influences without warning.

---

## Weight Normalization (Normative)

After influence resolution and the 4-joint cap:

- All weights MUST be non-negative
- Weights MUST be normalized to sum to 1.0 per vertex
- If all weights for a vertex are zero, the vertex falls back to default binding
  (armature root bone, weight 1.0)

Negative weights MUST be rejected as a validation error.

---

## Default Binding (Normative)

Vertices without any explicit joint influences (no per-primitive weights, no weight
maps, no external file entry) are rigidly bound to the **armature root bone** of
their binding with weight 1.0.

The armature root bone is the bone with `parent: none` in the bound armature.

---

## Linear Blend Skinning — LBS (Normative)

All conforming implementations MUST support Linear Blend Skinning as the deformation
solver.

For a vertex with bind-pose position **v**, the deformed position **v'** is:

```
v' = Σᵢ wᵢ · Mᵢ · IBMᵢ · v
```

Where:

- `wᵢ` — normalized weight for joint `i`
- `Mᵢ` — world-space transform of joint `i` at the current pose
- `IBMᵢ` — inverse bind matrix for joint `i`
- `v` — vertex position in mesh space (as a homogeneous coordinate, `[x, y, z, 1]`)
- The sum is over all joints influencing this vertex (up to 4)

Inverse bind matrices MUST be computed such that `IBMᵢ · v` transforms a vertex from
mesh space into the bind-pose local space of joint `i`.

---

## Validation Rules (v0.3 Additions)

A compiler MUST fail with a `ValidationError` if:

- `weight_maps[].primitive_id` does not reference a primitive in the bound mesh
- `overrides[].vertices` contains an index out of bounds for the primitive
- A `gradient.range` has `range[0] >= range[1]`
- A `gradient.axis` is not one of `x`, `y`, `z`
- Any `BoneWeight.weight` is negative
- Any `BoneWeight.bone_id` does not reference a bone in the bound armature
- An external weight file (`source`) cannot be found or is malformed
- An external weight file's `vertex_count` does not match the primitive's tessellated vertex count
- `weight_maps[]` has none of `gradients`, `overrides`, or `source`

A compiler MUST emit a **warning** (not an error) if:

- More than 4 joint influences are specified for any vertex (before capping)
- Per-primitive weights and a weight map both target the same primitive (weight map wins)

---

## Determinism (Normative)

Given identical `.rigy.yaml` inputs, a conforming implementation MUST produce a
**byte-identical glTF binary (GLB)** output, given the same compiler version.

This requirement is **normative conformance**, not an implementation hint: if two
implementations claim v0.3 conformance for the same inputs, they MUST emit identical
GLB bytes.

Determinism MUST apply to all stages, including but not limited to:
- YAML parsing and defaulting (no locale-dependent parsing)
- primitive tessellation vertex and index enumeration
- symmetry expansion and ID renaming
- weight-map evaluation (gradients and overrides)
- influence truncation, sorting, and renormalization
- floating-point operations (order of operations must be canonical)
- glTF JSON ordering, bufferView/accessor ordering, and binary layout

### Canonicalization Requirements

A conforming implementation MUST apply the following canonicalization rules:

1. **Vertex attribute and accessor ordering**
   - Mesh primitives MUST emit attributes in a stable order:
     `POSITION`, `NORMAL`, `TEXCOORD_0` (if present), then any additional attributes
     in lexicographic order by attribute name.
   - Accessors and bufferViews MUST be emitted in a stable topological order that
     is solely determined by the input.

2. **Influence ordering**
   - For a single vertex, influences MUST be sorted by:
     (a) descending `weight`, then
     (b) ascending `bone_id` (string compare), then
     (c) ascending `bone_index` (if used internally).
   - After sorting, only the first `max_influences` influences are kept, then weights
     are renormalized to sum to 1.0 (unless the sum is 0, in which case all weights
     remain 0).

3. **Floating-point serialization**
   - All vertex attributes and weights written to GLB buffers MUST be serialized as
     IEEE 754 little-endian `float32`, unless a later version of this spec defines
     a different encoding.

Implementations MAY provide non-deterministic or “best-effort” modes for debugging,
but such modes are **NON-CONFORMANT** with this specification.

---

## Symmetry Interaction

Symmetry expansion (`symmetry.mirror_x`) operates **before validation**, **before**
weight-map evaluation, and **before** glTF emission.

When a mesh is mirrored, the compiler MUST:
- Deep-copy all primitives, anchors, and other ID-bearing objects under the mirrored mesh
- Apply the configured rename rules deterministically (e.g., `_L` → `_R`)
- Preserve a stable output ordering (original items, then mirrored items in the same relative order)

### Geometry Orientation

Mirroring across X negates the handedness of triangle orientation. A conforming
implementation MUST ensure outward-facing geometry remains outward-facing after
mirroring, by applying a deterministic orientation fix (e.g., reversing triangle winding).

### Weight Maps Under Symmetry

Weight maps are deep-copied with renamed references:
- `primitive_id` references MUST be renamed according to the mesh rename rules
- `bone_id` references MUST be renamed if and only if the author has mirrored/renamed
  those bones in the armature (mirroring does not implicitly create bones)

Gradients are preserved, with the following adjustments:
- Gradient `axis: x` MUST invert its range: `range: [a,b]` becomes `[-b,-a]`
- Other axes (`y`, `z`) preserve their `range` values

### Vertex Addressing Under Symmetry

Per-vertex overrides that reference **vertex indices** are defined in tessellation output
vertex order. For symmetry to preserve index semantics, v0.3 REQUIRES primitive tessellation
to be **canonically ordered** and **mirror-symmetric**, such that:

- The mirrored primitive MUST produce the same vertex count as the original.
- Vertex index *i* in the original corresponds to vertex index *i* in the mirrored output,
  with X negated and orientation fixed as above.

If an implementation cannot satisfy this property for a primitive type, it MUST reject
vertex-index overrides for that primitive with a validation error.

External weight file paths are **not** mirrored in v0.3 — both sides reference the same file.

---

## Full Example

```yaml
rigy_version: "0.3"

meshes:
  - id: arm
    primitives:
      - id: upper
        type: capsule
        dimensions: [0.08, 0.3, 0.08]
        translation: [0, 0.85, 0]
      - id: lower
        type: capsule
        dimensions: [0.07, 0.28, 0.07]
        translation: [0, 0.55, 0]

armatures:
  - id: arm_rig
    bones:
      - id: shoulder
        head: [0, 1.0, 0]
        tail: [0, 0.7, 0]
        parent: none
      - id: elbow
        head: [0, 0.7, 0]
        tail: [0, 0.42, 0]
        parent: shoulder

bindings:
  - mesh_id: arm
    armature_id: arm_rig
    weights:
      - primitive_id: upper
        bones:
          - bone_id: shoulder
            weight: 1.0
      - primitive_id: lower
        bones:
          - bone_id: elbow
            weight: 1.0
    weight_maps:
      - primitive_id: upper
        gradients:
          - axis: y
            range: [0.72, 0.82]
            from: { bone_id: shoulder, weight: 1.0 }
            to:   { bone_id: elbow, weight: 1.0 }
      - primitive_id: lower
        gradients:
          - axis: y
            range: [0.55, 0.65]
            from: { bone_id: elbow, weight: 1.0 }
            to:   { bone_id: shoulder, weight: 1.0 }
```

In this example, the elbow joint region gets smooth weight blending between the
`shoulder` and `elbow` bones, while the bulk of each capsule remains rigidly
assigned via the per-primitive weights. The gradients override only the vertices
in the transition zone.

---

## Non-Goals (v0.3)

- Weight painting or authoring workflows
- Dual quaternion skinning
- Corrective blendshapes
- Muscle, soft tissue, or cloth simulation
- Physics-based deformation
- FBX-specific behaviors or compatibility guarantees

---

## Roadmap (Informative)

### v0.4–0.6: Higher Fidelity Deformation
- Dual quaternion skinning (optional solver alongside LBS)
- Pose-driven corrective blendshapes
- Additional per-vertex attribute channels
- Conformance test suite with expected-output assets

### v0.7+: Simulation Tiers
- Optional soft tissue and muscle deformation layers
- Cloth simulation integration
- Deformation processors operating alongside skinning

### v1.0: Stable Release
- Animation curves and timeline
- Constraints and IK
- Full conformance specification
