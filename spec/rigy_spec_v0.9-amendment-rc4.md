# Rigy Specification — Amendment v0.9 (RC4)

## 1. Overview

### 1.1 Purpose

Rigy v0.9 introduces a new primitive, `wedge`, and formalizes **primitive surface keys** while preserving Rigy’s determinism goals (same YAML → same generated geometry).

This amendment defines **primitive surfaces** as intrinsic, bounded, and concrete results of primitive tessellation. Surfaces are **not separate geometric objects**. They do not require plane equations, bounds, or analytic descriptions. Instead, they are **stable identifiers** for groups of triangles produced from a primitive’s base patches.

### 1.2 Goals

- Introduce the `wedge` primitive with fully specified canonical geometry, vertex/index emission, and triangle winding.
- Define **surface keys** for selected primitives and require deterministic surface provenance.
- Provide a byte-level conformance hook for `wedge` (reference input YAML + reference `.glb` generated by the conformance compiler).

### 1.3 Non-Goals

This amendment explicitly does **not** introduce:

- Plane abstractions
- User-authored surfaces
- New UV generators or new UV mapping rules beyond those already defined in prior spec versions
- Material assignment semantics
- Surface transforms, bounds, or analytic definitions

---

## 2. Versioning and Gating

### 2.1 Spec Identifier vs YAML Syntax

Identifiers like `box@1` and `wedge@1` refer to the **spec-defined version** of a primitive. v0.9 does **not** require a YAML syntax change.

- YAML uses `type: "box"` and `type: "wedge"`.
- The `@1` suffix is **spec-level notation only**.

### 2.2 Rigy Version Gate

A YAML document that uses `type: "wedge"`:

- **MUST** declare `version: "0.9"` (or later).
- A parser conforming to v0.9 **MUST** reject `type: "wedge"` in documents declaring an earlier version.

---

## 3. Surface Keys

### 3.1 Definition

A **surface key** is a canonical identifier for a bounded surface patch produced by a primitive’s base topology.

A surface is:

- **Intrinsic**: derived from the primitive’s definition
- **Bounded**: corresponds to a finite set of triangles
- **Concrete**: directly tied to generated mesh topology
- **Exclusive**: every generated triangle belongs to exactly one surface (when the primitive defines surfaces)

Surfaces are defined by **provenance**: which base patch produced a given triangle.

### 3.2 Normative Rules

1. A primitive **MAY** define a list of canonical surface keys.
2. If a primitive defines surface keys:
   - Tessellation **MUST** assign every generated triangle to exactly one surface key.
   - Surface assignment **MUST** be deterministic.
3. A triangle **MUST NOT** belong to more than one surface.
4. Surface keys **MUST NOT** overlap.
5. Surface keys are metadata only in v0.9 and do not alter geometry.

### 3.3 Scope in v0.9

In v0.9:

- `box` **MUST** define surface keys (Section 4.1).
- `wedge` **MUST** define surface keys (Section 4.2).
- All other primitives (e.g., `sphere`, `cylinder`, `capsule`) have **no surface keys in v0.9**.

Implementations **MUST NOT** treat “no surface keys” as an error. The absence of surface keys means “no surface provenance is defined for this primitive in this spec version.”

---

## 4. Primitive Surface Definitions

### 4.1 `box@1` Surfaces (Normative)

The `box` primitive defines exactly six surfaces:

`+x`, `-x`, `+y`, `-y`, `+z`, `-z`

Each key corresponds to the face whose outward normal points in the named axis direction.

---

### 4.2 `wedge@1` Primitive (Normative)

#### 4.2.1 Description

The `wedge` primitive is a right triangular prism formed by extruding a right triangle in the **XZ** plane along the **Y** axis.

It is defined by three positive dimensions:

- `x` (width, full extent in X)
- `y` (depth, full extent in Y)
- `z` (height, full extent in Z)

All dimensions **MUST** be strictly positive. Dimensions are full extents (not half-extents), consistent with `box`.

The wedge is centered on the origin in all three axes:

- X spans `[-x/2, +x/2]`
- Y spans `[-y/2, +y/2]`
- Z spans `[-z/2, +z/2]`

#### 4.2.2 Canonical Conceptual Vertices

Let `hx = x/2`, `hy = y/2`, `hz = z/2`. Define six conceptual vertices:

- `v0 = (-hx, -hy, -hz)`  (A0)
- `v1 = (+hx, -hy, -hz)`  (B0)
- `v2 = (-hx, -hy, +hz)`  (C0)
- `v3 = (-hx, +hy, -hz)`  (A1)
- `v4 = (+hx, +hy, -hz)`  (B1)
- `v5 = (-hx, +hy, +hz)`  (C1)

These are **conceptual** vertices for geometry definition. The emitted vertex buffer (Section 4.2.5) duplicates vertices as needed to ensure flat normals and (optionally) per-surface exclusivity.

At any fixed Y, the cross-section is the right triangle `(A, B, C)` where the right angle is at `A` and the legs run along +X and +Z.

#### 4.2.3 Surfaces (Normative)

To avoid semantic footguns, `wedge` surface keys use the same axis-based convention as `box` wherever possible.

The `wedge` primitive defines exactly five surfaces:

| Surface Key | Description |
|------------|-------------|
| `-z` | Rectangular face at `z = -hz` (outward normal `-z`) |
| `-x` | Rectangular face at `x = -hx` (outward normal `-x`) |
| `slope` | Sloped rectangular face connecting the hypotenuse edge (outward normal depends on `x` and `z`) |
| `+y` | Triangular face at `y = +hy` (outward normal `+y`) |
| `-y` | Triangular face at `y = -hy` (outward normal `-y`) |

#### 4.2.4 Canonical Triangle Topology (Conceptual)

Triangle winding **MUST** be counter-clockwise (CCW) when viewed from outside the mesh (right-handed coordinate system).

Using the conceptual vertices `v0..v5`, the wedge’s conceptual triangle topology is:

- `-y`: `(v0, v1, v2)`
- `+y`: `(v3, v5, v4)`
- `-z`: `(v0, v4, v1)` and `(v0, v3, v4)`
- `-x`: `(v0, v2, v5)` and `(v0, v5, v3)`
- `slope`: `(v1, v5, v2)` and `(v1, v4, v5)`

This topology fixes geometry and face membership. Section 4.2.5 fixes the emitted vertex/index buffers.

#### 4.2.5 Vertex and Index Emission (Normative)

To ensure byte-identical output, the `wedge` primitive **MUST** emit vertices and indices in the deterministic order below.

**Vertex count and index count (normative):**
- Emitted vertices: **18**
- Emitted triangles: **8**
- Emitted indices: **24** (8 × 3), `uint32`

**Flat normals and duplication rule (normative):**
- `wedge` **MUST** be flat-shaded.
- Vertices **MUST NOT** be shared across faces that have different normals.
- Vertices **MAY** be shared within a single face (surface), since all triangles on that face share the same normal.

**Emission order (normative):** emit faces in this order:

1. `-z` (rect)
2. `-x` (rect)
3. `slope` (rect)
4. `-y` (tri)
5. `+y` (tri)

For each face, emit the face’s **local vertex list** (positions + normals) followed by its indices, using a running base offset.

**Per-face local vertex lists and indices (normative):**

Let `emit_face(vertices, indices)` mean:
- append the face’s vertices to the global vertex buffer
- append the face’s indices to the global index buffer, with each index offset by the current global base vertex index
- then advance the base vertex index by `len(vertices)`

All positions below reference the conceptual vertex coordinates from Section 4.2.2. Normals are specified in Section 5.

- Face `-z`:
  - local vertices (4): `[v0, v1, v4, v3]`
  - local indices (6): `(0, 2, 1)`, `(0, 3, 2)`

- Face `-x`:
  - local vertices (4): `[v0, v3, v5, v2]`
  - local indices (6): `(0, 2, 3)`, `(0, 1, 2)`

- Face `slope`:
  - local vertices (4): `[v1, v2, v5, v4]`
  - local indices (6): `(0, 2, 1)`, `(0, 3, 2)`

- Face `-y`:
  - local vertices (3): `[v0, v1, v2]`
  - local indices (3): `(0, 1, 2)`

- Face `+y`:
  - local vertices (3): `[v3, v5, v4]`
  - local indices (3): `(0, 1, 2)`

This emission profile is the canonical wedge tessellation for v0.9.

#### 4.2.6 Surface Provenance (Normative)

Surface provenance for `wedge` is defined by the emitted face blocks:

- triangles emitted for each face belong to that face’s surface key
- no triangle belongs to more than one surface key

Subdivision is not introduced in v0.9 for `wedge`. Future versions may define tessellation levels; v0.9 does not.

---

## 5. Normals (Determinism)

Normals are required for byte-identical `.glb` output across implementations.

In v0.9, `box` and `wedge` **MUST** generate flat normals:

- For each emitted face, the normal for all vertices of that face is the unit-length face normal derived from its CCW winding.
- Implementations **MUST NOT** average normals across faces.

This pins down wedge slope normals deterministically: they are the face normal computed from the `slope` face triangles and the provided dimensions.

---

## 6. UV Generators and `wedge` (Clarification)

This amendment introduces no new UV rules.

If the base Rigy spec version that `wedge` is being added into includes mesh-level UV sets (e.g., v0.8 `uv_sets`), then `wedge` participates under the existing rules:

- Any UV generator declared on a mesh **MUST** be applicable to every primitive type present in that mesh (existing rule).
- Generators applicable to `all` primitives (e.g., `planar_xy@1`) apply to `wedge` without special casing.
- Generators applicable only to specific primitives (e.g., `box_project@1`) are invalid in meshes that contain `wedge`.

This amendment does not add a wedge-specific UV generator.

---

## 7. Dimensions and Validation

### 7.1 Strict Dimensions

All dimension parameters for `box` and `wedge`:

- **MUST** be finite numeric values
- **MUST** be strictly greater than zero
- **MUST NOT** be inferred, defaulted, or clamped

### 7.2 Validation IDs

This amendment does not introduce new dimension validation IDs. Dimension violations use existing Rigy validation IDs.

### 7.3 Implementation Invariants (Non-User-Facing)

The following conditions indicate a non-conforming implementation (or a bug), not invalid YAML input:

| ID | Condition |
|----|----------|
| I90 | Primitive defines surface keys but tessellation does not assign all triangles |
| I91 | Triangle assigned to more than one surface |
| I92 | Unknown surface key referenced internally |

---

## 8. Conformance Artifacts (Normative)

v0.9 introduces a reference conformance case:

- `C0901_wedge_2x2x2.rigy.yaml`

A conforming implementation **MUST** generate a `.glb` byte-identical to the reference `.glb` produced by the conformance compiler when compiling the reference YAML.

(As with other Rigy conformance cases, the reference `.glb` is derived from the spec and checked into the conformance suite; it is not authored in the spec text.)

---

### End of v0.9 Amendment (RC4)
